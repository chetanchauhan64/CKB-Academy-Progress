import { CellDep, OutPoint, Script, Transaction, epochFrom, hashTypeFrom, } from "../ckb/index.js";
import { hexFrom } from "../hex/index.js";
import { numFrom } from "../num/index.js";
import { apply } from "../utils/index.js";
import { clientSearchKeyRangeFrom, } from "./clientTypes.advanced.js";
/**
 * @public
 */
export class CellDepInfo {
    constructor(cellDep, type) {
        this.cellDep = cellDep;
        this.type = type;
    }
    static from(cellDepInfoLike) {
        if (cellDepInfoLike instanceof CellDepInfo) {
            return cellDepInfoLike;
        }
        return new CellDepInfo(CellDep.from(cellDepInfoLike.cellDep), apply(Script.from, cellDepInfoLike.type));
    }
}
/**
 * @public
 */
export class ScriptInfo {
    constructor(codeHash, hashType, cellDeps) {
        this.codeHash = codeHash;
        this.hashType = hashType;
        this.cellDeps = cellDeps;
    }
    static from(scriptInfoLike) {
        if (scriptInfoLike instanceof ScriptInfo) {
            return scriptInfoLike;
        }
        return new ScriptInfo(hexFrom(scriptInfoLike.codeHash), hashTypeFrom(scriptInfoLike.hashType), scriptInfoLike.cellDeps.map((c) => CellDepInfo.from(c)));
    }
}
/**
 * @public
 */
export class ClientTransactionResponse {
    constructor(transaction, status, cycles, blockHash, blockNumber, txIndex, reason) {
        this.transaction = transaction;
        this.status = status;
        this.cycles = cycles;
        this.blockHash = blockHash;
        this.blockNumber = blockNumber;
        this.txIndex = txIndex;
        this.reason = reason;
    }
    static from(responseLike) {
        if (responseLike instanceof ClientTransactionResponse) {
            return responseLike;
        }
        return new ClientTransactionResponse(Transaction.from(responseLike.transaction), responseLike.status, apply(numFrom, responseLike.cycles), apply(hexFrom, responseLike.blockHash), apply(numFrom, responseLike.blockNumber), apply(numFrom, responseLike.txIndex), responseLike.reason);
    }
    clone() {
        return new ClientTransactionResponse(this.transaction.clone(), this.status, this.cycles, this.blockHash, this.blockNumber, this.txIndex, this.reason);
    }
}
/**
 * @public
 */
export class ClientIndexerSearchKeyFilter {
    constructor(script, scriptLenRange, outputData, outputDataSearchMode, outputDataLenRange, outputCapacityRange, blockRange) {
        this.script = script;
        this.scriptLenRange = scriptLenRange;
        this.outputData = outputData;
        this.outputDataSearchMode = outputDataSearchMode;
        this.outputDataLenRange = outputDataLenRange;
        this.outputCapacityRange = outputCapacityRange;
        this.blockRange = blockRange;
    }
    static from(filterLike) {
        if (filterLike instanceof ClientIndexerSearchKeyFilter) {
            return filterLike;
        }
        return new ClientIndexerSearchKeyFilter(apply(Script.from, filterLike.script), apply(clientSearchKeyRangeFrom, filterLike.scriptLenRange), apply(hexFrom, filterLike.outputData), filterLike.outputDataSearchMode ?? undefined, apply(clientSearchKeyRangeFrom, filterLike.outputDataLenRange), apply(clientSearchKeyRangeFrom, filterLike.outputCapacityRange), apply(clientSearchKeyRangeFrom, filterLike.blockRange));
    }
}
/**
 * @public
 */
export class ClientIndexerSearchKey {
    constructor(script, scriptType, scriptSearchMode, filter, withData) {
        this.script = script;
        this.scriptType = scriptType;
        this.scriptSearchMode = scriptSearchMode;
        this.filter = filter;
        this.withData = withData;
    }
    static from(keyLike) {
        if (keyLike instanceof ClientIndexerSearchKey) {
            return keyLike;
        }
        return new ClientIndexerSearchKey(Script.from(keyLike.script), keyLike.scriptType, keyLike.scriptSearchMode, apply(ClientIndexerSearchKeyFilter.from, keyLike.filter), keyLike.withData ?? undefined);
    }
}
/**
 * @public
 */
export class ClientIndexerSearchKeyTransaction {
    constructor(script, scriptType, scriptSearchMode, filter, groupByTransaction) {
        this.script = script;
        this.scriptType = scriptType;
        this.scriptSearchMode = scriptSearchMode;
        this.filter = filter;
        this.groupByTransaction = groupByTransaction;
    }
    static from(keyLike) {
        if (keyLike instanceof ClientIndexerSearchKeyTransaction) {
            return keyLike;
        }
        return new ClientIndexerSearchKeyTransaction(Script.from(keyLike.script), keyLike.scriptType, keyLike.scriptSearchMode, apply(ClientIndexerSearchKeyFilter.from, keyLike.filter), keyLike.groupByTransaction ?? undefined);
    }
}
/**
 * @public
 */
export class ClientBlockHeader {
    constructor(compactTarget, dao, epoch, extraHash, hash, nonce, number, parentHash, proposalsHash, timestamp, transactionsRoot, version) {
        this.compactTarget = compactTarget;
        this.dao = dao;
        this.epoch = epoch;
        this.extraHash = extraHash;
        this.hash = hash;
        this.nonce = nonce;
        this.number = number;
        this.parentHash = parentHash;
        this.proposalsHash = proposalsHash;
        this.timestamp = timestamp;
        this.transactionsRoot = transactionsRoot;
        this.version = version;
    }
    static from(headerLike) {
        if (headerLike instanceof ClientBlockHeader) {
            return headerLike;
        }
        return new ClientBlockHeader(numFrom(headerLike.compactTarget), {
            c: numFrom(headerLike.dao.c),
            ar: numFrom(headerLike.dao.ar),
            s: numFrom(headerLike.dao.s),
            u: numFrom(headerLike.dao.u),
        }, epochFrom(headerLike.epoch), hexFrom(headerLike.extraHash), hexFrom(headerLike.hash), numFrom(headerLike.nonce), numFrom(headerLike.number), hexFrom(headerLike.parentHash), hexFrom(headerLike.proposalsHash), numFrom(headerLike.timestamp), hexFrom(headerLike.transactionsRoot), numFrom(headerLike.version));
    }
}
/**
 * @public
 */
export class ClientBlockUncle {
    constructor(header, proposals) {
        this.header = header;
        this.proposals = proposals;
    }
    static from(uncleLike) {
        if (uncleLike instanceof ClientBlockUncle) {
            return uncleLike;
        }
        return new ClientBlockUncle(ClientBlockHeader.from(uncleLike.header), uncleLike.proposals.map(hexFrom));
    }
}
/**
 * @public
 */
export class ClientBlock {
    constructor(header, proposals, transactions, uncles) {
        this.header = header;
        this.proposals = proposals;
        this.transactions = transactions;
        this.uncles = uncles;
    }
    static from(blockLike) {
        if (blockLike instanceof ClientBlock) {
            return blockLike;
        }
        return new ClientBlock(ClientBlockHeader.from(blockLike.header), blockLike.proposals.map(hexFrom), blockLike.transactions.map(Transaction.from), blockLike.uncles.map(ClientBlockUncle.from));
    }
}
export class ErrorClientBase extends Error {
    constructor(origin) {
        super(`Client request error ${origin.message}`);
        this.code = origin.code;
        this.data = origin.data;
    }
}
export class ErrorClientResolveUnknown extends ErrorClientBase {
    constructor(origin, outPointLike) {
        super(origin);
        this.outPoint = OutPoint.from(outPointLike);
    }
}
export class ErrorClientVerification extends ErrorClientBase {
    constructor(origin, source, sourceIndex, errorCode, scriptHashType, scriptCodeHash) {
        super(origin);
        this.source = source;
        this.errorCode = errorCode;
        this.scriptHashType = scriptHashType;
        this.sourceIndex = numFrom(sourceIndex);
        this.scriptCodeHash = hexFrom(scriptCodeHash);
    }
}
export class ErrorClientDuplicatedTransaction extends ErrorClientBase {
    constructor(origin, txHash) {
        super(origin);
        this.txHash = hexFrom(txHash);
    }
}
export class ErrorClientRBFRejected extends ErrorClientBase {
    constructor(origin, currentFee, leastFee) {
        super(origin);
        this.currentFee = numFrom(currentFee);
        this.leastFee = numFrom(leastFee);
    }
}
export class ErrorClientWaitTransactionTimeout extends ErrorClientBase {
    constructor(timeoutLike) {
        const timeout = numFrom(timeoutLike).toString();
        super({
            message: `Wait transaction timeout ${timeout}ms`,
            data: JSON.stringify({ timeout }),
        });
    }
}
export class ErrorClientMaxFeeRateExceeded extends ErrorClientBase {
    constructor(limitLike, actualLike) {
        const limit = numFrom(limitLike).toString();
        const actual = numFrom(actualLike).toString();
        super({
            message: `Max fee rate exceeded limit ${limit}, actual ${actual}. Developer might forgot to complete transaction fee before sending. See https://api.ckbccc.com/classes/_ckb_ccc_core.index.ccc.Transaction.html#completeFeeBy.`,
            data: JSON.stringify({ limit, actual }),
        });
    }
}
