"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }// src/index.ts












var _common = require('@joyid/common');
var _ckbsdkutils = require('@nervosnetwork/ckb-sdk-utils'); var ckbUtils = _interopRequireWildcard(_ckbsdkutils);

// src/aggregator.ts
var _crossfetch = require('cross-fetch'); var _crossfetch2 = _interopRequireDefault(_crossfetch);
var payloadId = () => Date.now();
var Aggregator = class {
  constructor(url) {
    this.url = url;
  }
  async baseRPC(method, req, url = this.url) {
    const payload = {
      id: payloadId(),
      jsonrpc: "2.0",
      method,
      params: _nullishCoalesce(req, () => ( null))
    };
    const body = JSON.stringify(payload, null, "");
    const data = await _crossfetch2.default.call(void 0, url, {
      method: "post",
      headers: {
        "Content-Type": "application/json"
      },
      body
    }).then(async (res) => res.json());
    if (data.error != null) {
      throw new Error(`RPC error: ${JSON.stringify(data.error)}`);
    }
    return data.result;
  }
  async generateSubkeyUnlockSmt(req) {
    return await this.baseRPC(
      "generate_subkey_unlock_smt",
      req
    );
  }
};

// src/utils.ts


function derToIEEE(sig) {
  const signature = Array.from(
    new Uint8Array(sig),
    (x) => `00${x.toString(16)}`.slice(-2)
  ).join("");
  const rLength = Number.parseInt(signature.substr(6, 2), 16) * 2;
  let r = signature.substr(8, rLength);
  let s = signature.substr(12 + rLength);
  r = r.length > 64 ? r.substr(-64) : r.padStart(64, "0");
  s = s.length > 64 ? s.substr(-64) : s.padStart(64, "0");
  const p1363Sig = `${r}${s}`;
  return new Uint8Array(
    p1363Sig.match(/[\da-f]{2}/gi).map((h) => Number.parseInt(h, 16))
  );
}
function leHexStringToU32(hex) {
  const bytes = _ckbsdkutils.hexToBytes.call(void 0, _common.append0x.call(void 0, hex));
  const beHex = `0x${bytes.reduceRight((pre, cur) => pre + cur.toString(16).padStart(2, "0"), "")}`;
  return Number.parseInt(beHex);
}
function deserializeWitnessArgs(hex) {
  const args = _common.remove0x.call(void 0, hex);
  const lockOffset = leHexStringToU32(args.slice(8, 16)) * 2;
  const inputTypeOffset = leHexStringToU32(args.slice(16, 24)) * 2;
  const outputTypeOffset = leHexStringToU32(args.slice(24, 32)) * 2;
  const lock = args.slice(lockOffset, inputTypeOffset).slice(8);
  const inputType = args.slice(inputTypeOffset, outputTypeOffset).slice(8);
  const outputType = args.slice(outputTypeOffset).slice(8);
  return {
    lock: lock.length === 0 ? "0x" : `0x${lock}`,
    inputType: inputType.length === 0 ? "0x" : `0x${inputType}`,
    outputType: outputType.length === 0 ? "0x" : `0x${outputType}`
  };
}

// src/verify.ts

var _uncrypto = require('uncrypto');











var ensureChallenge = (challenge, clientData) => {
  try {
    const clienDataJSON = _common.hexToString.call(void 0, _common.bufferToHex.call(void 0, clientData));
    const clientDataObj = JSON.parse(clienDataJSON);
    return clientDataObj.challenge === _common.bufferToBase64URLString.call(void 0, _common.utf8StringToBuffer.call(void 0, challenge));
  } catch (error) {
    return false;
  }
};
var verifySessionKeySignature = async (message, signature, pubkey) => {
  try {
    const algoName = "RSASSA-PKCS1-v1_5";
    const pk = _common.hexToArrayBuffer.call(void 0, pubkey);
    const msg = _common.base64URLStringToBuffer.call(void 0, message);
    const sig = _common.base64URLStringToBuffer.call(void 0, signature);
    const e = new Uint8Array(pk.slice(0, 3)).reverse();
    const n = new Uint8Array(pk.slice(4)).reverse();
    const jwkPubkey = {
      alg: "RS256",
      ext: true,
      key_ops: ["verify"],
      kty: "RSA",
      e: _common.bufferToBase64URLString.call(void 0, e),
      n: _common.bufferToBase64URLString.call(void 0, n)
    };
    const key = await _uncrypto.subtle.importKey(
      "jwk",
      jwkPubkey,
      {
        name: algoName,
        hash: "SHA-256"
      },
      false,
      ["verify"]
    );
    const res = await _uncrypto.subtle.verify(algoName, key, sig, msg);
    return res;
  } catch (error) {
    console.error(error);
    return false;
  }
};
var verifyNativeKeySignature = async ({
  message,
  signature,
  pubkey,
  challenge,
  alg
}) => {
  try {
    const pk = _common.hexToArrayBuffer.call(void 0, `${pubkey}`);
    const msg = _common.base64URLStringToBuffer.call(void 0, message);
    const sig = _common.base64URLStringToBuffer.call(void 0, signature);
    const authData = msg.slice(0, 37);
    const clientData = msg.slice(37);
    if (!ensureChallenge(challenge, clientData)) {
      return false;
    }
    const clientDataHash = await _uncrypto.subtle.digest("SHA-256", clientData);
    const signatureBase = _common.appendBuffer.call(void 0, authData, clientDataHash);
    const isR1 = alg === _common.SigningAlg.ES256;
    const jwkPubkey = isR1 ? {
      kty: "EC",
      crv: "P-256",
      x: _common.bufferToBase64URLString.call(void 0, pk.slice(0, 32)),
      y: _common.bufferToBase64URLString.call(void 0, pk.slice(32))
    } : {
      alg: "RS256",
      ext: true,
      key_ops: ["verify"],
      kty: "RSA",
      e: _common.bufferToBase64URLString.call(void 0, new Uint8Array(pk.slice(0, 3)).reverse()),
      n: _common.bufferToBase64URLString.call(void 0, new Uint8Array(pk.slice(4)).reverse())
    };
    const algo = isR1 ? {
      name: "ECDSA",
      namedCurve: "P-256",
      hash: { name: "SHA-256" }
    } : {
      name: "RSASSA-PKCS1-v1_5",
      hash: "SHA-256"
    };
    const key = await _uncrypto.subtle.importKey("jwk", jwkPubkey, algo, false, [
      "verify"
    ]);
    const res = await _uncrypto.subtle.verify(
      algo,
      key,
      alg === _common.SigningAlg.RS256 ? sig : derToIEEE(sig),
      signatureBase
    );
    return res;
  } catch (error) {
    console.error(error);
    return false;
  }
};
var verifySignature = async (data) => {
  const { message, signature, pubkey, keyType } = data;
  if (keyType === "main_key" || keyType === "sub_key") {
    return verifyNativeKeySignature(data);
  }
  return verifySessionKeySignature(message, signature, pubkey);
};
async function verifyCredential(credentialOrPubkey, addressOrJoyidServerURL, _keyType, _alg) {
  let pubkey, address, keyType, alg;
  let serverURL = _common.getConfig.call(void 0, ).joyidServerURL;
  if (typeof credentialOrPubkey === "string") {
    pubkey = credentialOrPubkey;
    address = addressOrJoyidServerURL;
    keyType = _keyType;
    alg = _alg;
  } else {
    ;
    ({ pubkey, address, keyType, alg } = credentialOrPubkey);
    serverURL = addressOrJoyidServerURL;
  }
  try {
    const result = await _crossfetch2.default.call(void 0, `${serverURL}/credentials/${address}`, {
      method: "GET",
      headers: {
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36"
      }
    }).then(async (res) => res.json());
    return result.credentials.some((c) => {
      const pk = alg === _common.SigningAlg.RS256 || keyType === "main_session_key" || keyType === "sub_session_key" ? c.public_key : c.public_key.slice(2);
      return c.ckb_address === address && pk === pubkey;
    });
  } catch (error) {
    console.error(error);
    return false;
  }
}

// src/index.ts





// src/constants.ts
var TestnetInfo = {
  JoyIDLockScript: {
    codeHash: "0xd23761b364210735c19c60561d213fb3beae2fd6172743719eff6920e020baac",
    hashType: "type",
    args: ""
  },
  JoyIDLockDep: {
    outPoint: {
      txHash: "0x4dcf3f3b09efac8995d6cbee87c5345e812d310094651e0c3d9a730f32dc9263",
      index: "0x0"
    },
    depType: "depGroup"
  },
  CotaTypeScript: {
    codeHash: "0x89cd8003a0eaf8e65e0c31525b7d1d5c1becefd2ea75bb4cff87810ae37764d8",
    hashType: "type",
    args: "0x"
  },
  CotaTypeDep: {
    outPoint: {
      txHash: "0x636a786001f87cb615acfcf408be0f9a1f077001f0bbc75ca54eadfe7e221713",
      index: "0x0"
    },
    depType: "depGroup"
  }
};
var MainnetInfo = {
  JoyIDLockScript: {
    codeHash: "0xd00c84f0ec8fd441c38bc3f87a371f547190f2fcff88e642bc5bf54b9e318323",
    hashType: "type",
    args: ""
  },
  JoyIDLockDep: {
    outPoint: {
      txHash: "0xf05188e5f3a6767fc4687faf45ba5f1a6e25d3ada6129dae8722cb282f262493",
      index: "0x0"
    },
    depType: "depGroup"
  },
  CotaTypeScript: {
    codeHash: "0x1122a4fb54697cf2e6e3a96c9d80fd398a936559b90954c6e88eb7ba0cf652df",
    hashType: "type",
    args: "0x"
  },
  CotaTypeDep: {
    outPoint: {
      txHash: "0xabaa25237554f0d6c586dc010e7e85e6870bcfd9fb8773257ecacfbe1fd738a0",
      index: "0x0"
    },
    depType: "depGroup"
  }
};
var getJoyIDLockScript = (isMainnet) => isMainnet ? MainnetInfo.JoyIDLockScript : TestnetInfo.JoyIDLockScript;
var getJoyIDCellDep = (isMainnet) => isMainnet ? MainnetInfo.JoyIDLockDep : TestnetInfo.JoyIDLockDep;
var getCotaTypeScript = (isMainnet) => isMainnet ? MainnetInfo.CotaTypeScript : TestnetInfo.CotaTypeScript;
var getCotaCellDep = (isMainnet) => isMainnet ? MainnetInfo.CotaTypeDep : TestnetInfo.CotaTypeDep;

// src/index.ts
var {
  PERSONAL,
  addressToScript,
  blake160,
  blake2b,
  hexToBytes: hexToBytes2,
  toUint64Le,
  serializeScript,
  rawTransactionToHash,
  serializeWitnessArgs
} = ckbUtils;
var appendPrefix = (tokenKey) => {
  if (!tokenKey) {
    return tokenKey;
  }
  const key = _common.remove0x.call(void 0, tokenKey);
  if (key.length === 48) {
    return `ffffffff${key}`;
  }
  return key;
};
var generateSignURL = (config, isCkb = true) => {
  const { joyidAppURL: __, joyidServerURL: _, ...ckbDappConfig } = config;
  const path = isCkb ? "/sign-ckb" : "/sign-cota-nft";
  const dappConfig = ckbDappConfig;
  if (!isCkb) {
    const tx = dappConfig.tx;
    tx.tokenKey = appendPrefix(tx.tokenKey);
    dappConfig.tx = tx;
  }
  return _common.buildJoyIDURL.call(void 0, dappConfig, "popup", path);
};
var initConfig = (config) => {
  Object.assign(_common.internalConfig, config);
  return _common.internalConfig;
};
var getConfig2 = () => _common.internalConfig;
var connect = async (config) => {
  config = {
    ..._common.internalConfig,
    ...config
  };
  const res = await _common.authWithPopup.call(void 0, {
    redirectURL: location.href,
    ...config
  });
  return res;
};
var signChallenge = async (challenge, signerAddress, config) => {
  const isData = typeof challenge !== "string";
  config = {
    ..._common.internalConfig,
    ...config
  };
  const res = await _common.signMessageWithPopup.call(void 0, {
    challenge: typeof challenge === "string" ? challenge : _common.bufferToHex.call(void 0, challenge),
    isData,
    address: signerAddress,
    redirectURL: location.href,
    ...config
  });
  return res;
};
var signTransaction = async (tx, config) => {
  config = {
    ..._common.internalConfig,
    ...config
  };
  if (!config.popup) {
    config.popup = _common.openPopup.call(void 0, "");
    if (!config.popup) {
      return _common.createBlockDialog.call(void 0, async () => signTransaction(tx, config));
    }
  }
  const { popup, timeoutInSeconds, ...dappConfig } = config;
  config.popup.location.href = generateSignURL({
    ...dappConfig,
    tx,
    signerAddress: tx.from,
    redirectURL: location.href
  });
  const res = await _common.runPopup.call(void 0, {
    timeoutInSeconds: _nullishCoalesce(timeoutInSeconds, () => ( 5e3)),
    popup,
    type: _common.DappRequestType.SignCkbTx
  });
  return res.tx;
};
var signCotaNFTTx = async (tx, config) => {
  config = {
    ..._common.internalConfig,
    ...config
  };
  if (!config.popup) {
    config.popup = _common.openPopup.call(void 0, "");
    if (!config.popup) {
      return _common.createBlockDialog.call(void 0, async () => signCotaNFTTx(tx, config));
    }
  }
  const { popup, timeoutInSeconds, ...dappConfig } = config;
  config.popup.location.href = generateSignURL(
    {
      ...dappConfig,
      tx,
      signerAddress: tx.from,
      redirectURL: location.href
    },
    false
  );
  const res = await _common.runPopup.call(void 0, {
    timeoutInSeconds: _nullishCoalesce(timeoutInSeconds, () => ( 5e3)),
    popup,
    type: _common.DappRequestType.SignCotaNFT
  });
  return res.tx;
};
var signRawTransaction = async (tx, signerAddress, config) => {
  config = {
    ...tx,
    ..._common.internalConfig,
    ...config
  };
  const { witnessIndexes } = config;
  if (Array.isArray(witnessIndexes)) {
    if (witnessIndexes.length === 0) {
      throw new Error("The witnessIndexes must be not empty");
    }
    if (witnessIndexes.length > tx.inputs.length) {
      throw new Error(
        "The length of witnessIndexes must not be bigger than the length of inputs"
      );
    }
  }
  if (!config.popup) {
    config.popup = _common.openPopup.call(void 0, "");
    if (!config.popup) {
      return _common.createBlockDialog.call(void 0, 
        async () => signRawTransaction(tx, signerAddress, config)
      );
    }
  }
  const { popup, timeoutInSeconds, ...ckbDappConfig } = config;
  config.popup.location.href = _common.buildJoyIDURL.call(void 0, 
    {
      ...ckbDappConfig,
      tx,
      signerAddress,
      redirectURL: location.href
    },
    "popup",
    "/sign-ckb-raw-tx"
  );
  const res = await _common.runPopup.call(void 0, {
    timeoutInSeconds: _nullishCoalesce(timeoutInSeconds, () => ( 5e3)),
    popup,
    type: _common.DappRequestType.SignCkbRawTx
  });
  return res.tx;
};
var SECP256R1_PUBKEY_SIG_LEN = 129;
var calculateChallenge = async (tx, witnessIndexes = [0]) => {
  const { witnesses } = tx;
  if (witnesses.length === 0) {
    throw new Error("Witnesses cannot be empty");
  }
  if (witnessIndexes.length === 0) {
    throw new Error("JoyID witnesses can not be empty");
  }
  const firstWitnessIndex = _nullishCoalesce(witnessIndexes[0], () => ( 0));
  if (typeof tx.witnesses[firstWitnessIndex] !== "string") {
    throw new TypeError(
      "The first JoyID witness must be serialized hex string of WitnessArgs"
    );
  }
  const transactionHash = rawTransactionToHash(tx);
  const witnessArgs = deserializeWitnessArgs(tx.witnesses[firstWitnessIndex]);
  const emptyWitness = {
    ...witnessArgs,
    lock: `0x${"00".repeat(SECP256R1_PUBKEY_SIG_LEN)}`
  };
  console.log(console.log(emptyWitness));
  const serializedEmptyWitnessBytes = hexToBytes2(
    serializeWitnessArgs(emptyWitness)
  );
  const serializedEmptyWitnessSize = serializedEmptyWitnessBytes.length;
  const hasher = blake2b(32, null, null, PERSONAL);
  hasher.update(hexToBytes2(transactionHash));
  hasher.update(
    hexToBytes2(toUint64Le(`0x${serializedEmptyWitnessSize.toString(16)}`))
  );
  hasher.update(serializedEmptyWitnessBytes);
  for (const witnessIndex of witnessIndexes.slice(1)) {
    const witness = witnesses[witnessIndex];
    if (witness) {
      const bytes = hexToBytes2(
        typeof witness === "string" ? witness : serializeWitnessArgs(witness)
      );
      hasher.update(hexToBytes2(toUint64Le(`0x${bytes.length.toString(16)}`)));
      hasher.update(bytes);
    }
  }
  if (witnesses.length > tx.inputs.length) {
    for (const witness of witnesses.slice(tx.inputs.length)) {
      const bytes = hexToBytes2(
        typeof witness === "string" ? witness : serializeWitnessArgs(witness)
      );
      hasher.update(hexToBytes2(toUint64Le(`0x${bytes.length.toString(16)}`)));
      hasher.update(bytes);
    }
  }
  const challenge = `${hasher.digest("hex")}`;
  return challenge;
};
var WITNESS_NATIVE_MODE = "01";
var WITNESS_SUBKEY_MODE = "02";
var buildSignedTx = (unsignedTx, signedData, witnessIndexes = [0]) => {
  if (unsignedTx.witnesses.length === 0) {
    throw new Error("Witnesses length error");
  }
  const firstWitnessIndex = _nullishCoalesce(witnessIndexes[0], () => ( 0));
  const firstWitness = unsignedTx.witnesses[firstWitnessIndex];
  const witnessArgs = deserializeWitnessArgs(firstWitness);
  const { message, signature, pubkey, keyType } = signedData;
  const mode = keyType === "sub_key" ? WITNESS_SUBKEY_MODE : WITNESS_NATIVE_MODE;
  witnessArgs.lock = `0x${mode}${pubkey}${signature}${message}`;
  const signedWitness = _common.append0x.call(void 0, serializeWitnessArgs(witnessArgs));
  const signedTx = unsignedTx;
  signedTx.witnesses[firstWitnessIndex] = signedWitness;
  return signedTx;
};
var getSubkeyUnlock = async (aggregatorUrl, connection) => {
  const pubkeyHash = _common.append0x.call(void 0, blake160(_common.append0x.call(void 0, connection.pubkey), "hex"));
  const lock = addressToScript(connection.address);
  const req = {
    lock_script: serializeScript(lock),
    pubkey_hash: pubkeyHash,
    alg_index: 1
    // secp256r1
  };
  const aggregator = new Aggregator(aggregatorUrl);
  const { unlock_entry: unlockEntry } = await aggregator.generateSubkeyUnlockSmt(req);
  return unlockEntry;
};























exports.Aggregator = Aggregator; exports.SigningAlg = _common.SigningAlg; exports.buildSignedTx = buildSignedTx; exports.calculateChallenge = calculateChallenge; exports.connect = connect; exports.ensureChallenge = ensureChallenge; exports.getConfig = getConfig2; exports.getCotaCellDep = getCotaCellDep; exports.getCotaTypeScript = getCotaTypeScript; exports.getJoyIDCellDep = getJoyIDCellDep; exports.getJoyIDLockScript = getJoyIDLockScript; exports.getSubkeyUnlock = getSubkeyUnlock; exports.initConfig = initConfig; exports.openPopup = _common.openPopup; exports.signChallenge = signChallenge; exports.signCotaNFTTx = signCotaNFTTx; exports.signRawTransaction = signRawTransaction; exports.signTransaction = signTransaction; exports.verifyCredential = verifyCredential; exports.verifyNativeKeySignature = verifyNativeKeySignature; exports.verifySessionKeySignature = verifySessionKeySignature; exports.verifySignature = verifySignature;
//# sourceMappingURL=index.js.map