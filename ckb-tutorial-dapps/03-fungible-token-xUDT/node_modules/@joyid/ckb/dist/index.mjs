// src/index.ts
import {
  createBlockDialog,
  buildJoyIDURL,
  openPopup,
  runPopup,
  authWithPopup,
  signMessageWithPopup,
  internalConfig as internalDappConfig,
  DappRequestType,
  bufferToHex as bufferToHex2,
  append0x as append0x2,
  remove0x as remove0x2
} from "@joyid/common";
import * as ckbUtils from "@nervosnetwork/ckb-sdk-utils";

// src/aggregator.ts
import fetch from "cross-fetch";
var payloadId = () => Date.now();
var Aggregator = class {
  constructor(url) {
    this.url = url;
  }
  async baseRPC(method, req, url = this.url) {
    const payload = {
      id: payloadId(),
      jsonrpc: "2.0",
      method,
      params: req ?? null
    };
    const body = JSON.stringify(payload, null, "");
    const data = await fetch(url, {
      method: "post",
      headers: {
        "Content-Type": "application/json"
      },
      body
    }).then(async (res) => res.json());
    if (data.error != null) {
      throw new Error(`RPC error: ${JSON.stringify(data.error)}`);
    }
    return data.result;
  }
  async generateSubkeyUnlockSmt(req) {
    return await this.baseRPC(
      "generate_subkey_unlock_smt",
      req
    );
  }
};

// src/utils.ts
import { append0x, remove0x } from "@joyid/common";
import { hexToBytes } from "@nervosnetwork/ckb-sdk-utils";
function derToIEEE(sig) {
  const signature = Array.from(
    new Uint8Array(sig),
    (x) => `00${x.toString(16)}`.slice(-2)
  ).join("");
  const rLength = Number.parseInt(signature.substr(6, 2), 16) * 2;
  let r = signature.substr(8, rLength);
  let s = signature.substr(12 + rLength);
  r = r.length > 64 ? r.substr(-64) : r.padStart(64, "0");
  s = s.length > 64 ? s.substr(-64) : s.padStart(64, "0");
  const p1363Sig = `${r}${s}`;
  return new Uint8Array(
    p1363Sig.match(/[\da-f]{2}/gi).map((h) => Number.parseInt(h, 16))
  );
}
function leHexStringToU32(hex) {
  const bytes = hexToBytes(append0x(hex));
  const beHex = `0x${bytes.reduceRight((pre, cur) => pre + cur.toString(16).padStart(2, "0"), "")}`;
  return Number.parseInt(beHex);
}
function deserializeWitnessArgs(hex) {
  const args = remove0x(hex);
  const lockOffset = leHexStringToU32(args.slice(8, 16)) * 2;
  const inputTypeOffset = leHexStringToU32(args.slice(16, 24)) * 2;
  const outputTypeOffset = leHexStringToU32(args.slice(24, 32)) * 2;
  const lock = args.slice(lockOffset, inputTypeOffset).slice(8);
  const inputType = args.slice(inputTypeOffset, outputTypeOffset).slice(8);
  const outputType = args.slice(outputTypeOffset).slice(8);
  return {
    lock: lock.length === 0 ? "0x" : `0x${lock}`,
    inputType: inputType.length === 0 ? "0x" : `0x${inputType}`,
    outputType: outputType.length === 0 ? "0x" : `0x${outputType}`
  };
}

// src/verify.ts
import fetch2 from "cross-fetch";
import { subtle } from "uncrypto";
import {
  SigningAlg,
  getConfig,
  bufferToHex,
  appendBuffer,
  base64URLStringToBuffer,
  bufferToBase64URLString,
  hexToArrayBuffer,
  hexToString,
  utf8StringToBuffer
} from "@joyid/common";
var ensureChallenge = (challenge, clientData) => {
  try {
    const clienDataJSON = hexToString(bufferToHex(clientData));
    const clientDataObj = JSON.parse(clienDataJSON);
    return clientDataObj.challenge === bufferToBase64URLString(utf8StringToBuffer(challenge));
  } catch (error) {
    return false;
  }
};
var verifySessionKeySignature = async (message, signature, pubkey) => {
  try {
    const algoName = "RSASSA-PKCS1-v1_5";
    const pk = hexToArrayBuffer(pubkey);
    const msg = base64URLStringToBuffer(message);
    const sig = base64URLStringToBuffer(signature);
    const e = new Uint8Array(pk.slice(0, 3)).reverse();
    const n = new Uint8Array(pk.slice(4)).reverse();
    const jwkPubkey = {
      alg: "RS256",
      ext: true,
      key_ops: ["verify"],
      kty: "RSA",
      e: bufferToBase64URLString(e),
      n: bufferToBase64URLString(n)
    };
    const key = await subtle.importKey(
      "jwk",
      jwkPubkey,
      {
        name: algoName,
        hash: "SHA-256"
      },
      false,
      ["verify"]
    );
    const res = await subtle.verify(algoName, key, sig, msg);
    return res;
  } catch (error) {
    console.error(error);
    return false;
  }
};
var verifyNativeKeySignature = async ({
  message,
  signature,
  pubkey,
  challenge,
  alg
}) => {
  try {
    const pk = hexToArrayBuffer(`${pubkey}`);
    const msg = base64URLStringToBuffer(message);
    const sig = base64URLStringToBuffer(signature);
    const authData = msg.slice(0, 37);
    const clientData = msg.slice(37);
    if (!ensureChallenge(challenge, clientData)) {
      return false;
    }
    const clientDataHash = await subtle.digest("SHA-256", clientData);
    const signatureBase = appendBuffer(authData, clientDataHash);
    const isR1 = alg === SigningAlg.ES256;
    const jwkPubkey = isR1 ? {
      kty: "EC",
      crv: "P-256",
      x: bufferToBase64URLString(pk.slice(0, 32)),
      y: bufferToBase64URLString(pk.slice(32))
    } : {
      alg: "RS256",
      ext: true,
      key_ops: ["verify"],
      kty: "RSA",
      e: bufferToBase64URLString(new Uint8Array(pk.slice(0, 3)).reverse()),
      n: bufferToBase64URLString(new Uint8Array(pk.slice(4)).reverse())
    };
    const algo = isR1 ? {
      name: "ECDSA",
      namedCurve: "P-256",
      hash: { name: "SHA-256" }
    } : {
      name: "RSASSA-PKCS1-v1_5",
      hash: "SHA-256"
    };
    const key = await subtle.importKey("jwk", jwkPubkey, algo, false, [
      "verify"
    ]);
    const res = await subtle.verify(
      algo,
      key,
      alg === SigningAlg.RS256 ? sig : derToIEEE(sig),
      signatureBase
    );
    return res;
  } catch (error) {
    console.error(error);
    return false;
  }
};
var verifySignature = async (data) => {
  const { message, signature, pubkey, keyType } = data;
  if (keyType === "main_key" || keyType === "sub_key") {
    return verifyNativeKeySignature(data);
  }
  return verifySessionKeySignature(message, signature, pubkey);
};
async function verifyCredential(credentialOrPubkey, addressOrJoyidServerURL, _keyType, _alg) {
  let pubkey, address, keyType, alg;
  let serverURL = getConfig().joyidServerURL;
  if (typeof credentialOrPubkey === "string") {
    pubkey = credentialOrPubkey;
    address = addressOrJoyidServerURL;
    keyType = _keyType;
    alg = _alg;
  } else {
    ;
    ({ pubkey, address, keyType, alg } = credentialOrPubkey);
    serverURL = addressOrJoyidServerURL;
  }
  try {
    const result = await fetch2(`${serverURL}/credentials/${address}`, {
      method: "GET",
      headers: {
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36"
      }
    }).then(async (res) => res.json());
    return result.credentials.some((c) => {
      const pk = alg === SigningAlg.RS256 || keyType === "main_session_key" || keyType === "sub_session_key" ? c.public_key : c.public_key.slice(2);
      return c.ckb_address === address && pk === pubkey;
    });
  } catch (error) {
    console.error(error);
    return false;
  }
}

// src/index.ts
import {
  SigningAlg as SigningAlg2,
  openPopup as openPopup2
} from "@joyid/common";

// src/constants.ts
var TestnetInfo = {
  JoyIDLockScript: {
    codeHash: "0xd23761b364210735c19c60561d213fb3beae2fd6172743719eff6920e020baac",
    hashType: "type",
    args: ""
  },
  JoyIDLockDep: {
    outPoint: {
      txHash: "0x4dcf3f3b09efac8995d6cbee87c5345e812d310094651e0c3d9a730f32dc9263",
      index: "0x0"
    },
    depType: "depGroup"
  },
  CotaTypeScript: {
    codeHash: "0x89cd8003a0eaf8e65e0c31525b7d1d5c1becefd2ea75bb4cff87810ae37764d8",
    hashType: "type",
    args: "0x"
  },
  CotaTypeDep: {
    outPoint: {
      txHash: "0x636a786001f87cb615acfcf408be0f9a1f077001f0bbc75ca54eadfe7e221713",
      index: "0x0"
    },
    depType: "depGroup"
  }
};
var MainnetInfo = {
  JoyIDLockScript: {
    codeHash: "0xd00c84f0ec8fd441c38bc3f87a371f547190f2fcff88e642bc5bf54b9e318323",
    hashType: "type",
    args: ""
  },
  JoyIDLockDep: {
    outPoint: {
      txHash: "0xf05188e5f3a6767fc4687faf45ba5f1a6e25d3ada6129dae8722cb282f262493",
      index: "0x0"
    },
    depType: "depGroup"
  },
  CotaTypeScript: {
    codeHash: "0x1122a4fb54697cf2e6e3a96c9d80fd398a936559b90954c6e88eb7ba0cf652df",
    hashType: "type",
    args: "0x"
  },
  CotaTypeDep: {
    outPoint: {
      txHash: "0xabaa25237554f0d6c586dc010e7e85e6870bcfd9fb8773257ecacfbe1fd738a0",
      index: "0x0"
    },
    depType: "depGroup"
  }
};
var getJoyIDLockScript = (isMainnet) => isMainnet ? MainnetInfo.JoyIDLockScript : TestnetInfo.JoyIDLockScript;
var getJoyIDCellDep = (isMainnet) => isMainnet ? MainnetInfo.JoyIDLockDep : TestnetInfo.JoyIDLockDep;
var getCotaTypeScript = (isMainnet) => isMainnet ? MainnetInfo.CotaTypeScript : TestnetInfo.CotaTypeScript;
var getCotaCellDep = (isMainnet) => isMainnet ? MainnetInfo.CotaTypeDep : TestnetInfo.CotaTypeDep;

// src/index.ts
var {
  PERSONAL,
  addressToScript,
  blake160,
  blake2b,
  hexToBytes: hexToBytes2,
  toUint64Le,
  serializeScript,
  rawTransactionToHash,
  serializeWitnessArgs
} = ckbUtils;
var appendPrefix = (tokenKey) => {
  if (!tokenKey) {
    return tokenKey;
  }
  const key = remove0x2(tokenKey);
  if (key.length === 48) {
    return `ffffffff${key}`;
  }
  return key;
};
var generateSignURL = (config, isCkb = true) => {
  const { joyidAppURL: __, joyidServerURL: _, ...ckbDappConfig } = config;
  const path = isCkb ? "/sign-ckb" : "/sign-cota-nft";
  const dappConfig = ckbDappConfig;
  if (!isCkb) {
    const tx = dappConfig.tx;
    tx.tokenKey = appendPrefix(tx.tokenKey);
    dappConfig.tx = tx;
  }
  return buildJoyIDURL(dappConfig, "popup", path);
};
var initConfig = (config) => {
  Object.assign(internalDappConfig, config);
  return internalDappConfig;
};
var getConfig2 = () => internalDappConfig;
var connect = async (config) => {
  config = {
    ...internalDappConfig,
    ...config
  };
  const res = await authWithPopup({
    redirectURL: location.href,
    ...config
  });
  return res;
};
var signChallenge = async (challenge, signerAddress, config) => {
  const isData = typeof challenge !== "string";
  config = {
    ...internalDappConfig,
    ...config
  };
  const res = await signMessageWithPopup({
    challenge: typeof challenge === "string" ? challenge : bufferToHex2(challenge),
    isData,
    address: signerAddress,
    redirectURL: location.href,
    ...config
  });
  return res;
};
var signTransaction = async (tx, config) => {
  config = {
    ...internalDappConfig,
    ...config
  };
  if (!config.popup) {
    config.popup = openPopup("");
    if (!config.popup) {
      return createBlockDialog(async () => signTransaction(tx, config));
    }
  }
  const { popup, timeoutInSeconds, ...dappConfig } = config;
  config.popup.location.href = generateSignURL({
    ...dappConfig,
    tx,
    signerAddress: tx.from,
    redirectURL: location.href
  });
  const res = await runPopup({
    timeoutInSeconds: timeoutInSeconds ?? 5e3,
    popup,
    type: DappRequestType.SignCkbTx
  });
  return res.tx;
};
var signCotaNFTTx = async (tx, config) => {
  config = {
    ...internalDappConfig,
    ...config
  };
  if (!config.popup) {
    config.popup = openPopup("");
    if (!config.popup) {
      return createBlockDialog(async () => signCotaNFTTx(tx, config));
    }
  }
  const { popup, timeoutInSeconds, ...dappConfig } = config;
  config.popup.location.href = generateSignURL(
    {
      ...dappConfig,
      tx,
      signerAddress: tx.from,
      redirectURL: location.href
    },
    false
  );
  const res = await runPopup({
    timeoutInSeconds: timeoutInSeconds ?? 5e3,
    popup,
    type: DappRequestType.SignCotaNFT
  });
  return res.tx;
};
var signRawTransaction = async (tx, signerAddress, config) => {
  config = {
    ...tx,
    ...internalDappConfig,
    ...config
  };
  const { witnessIndexes } = config;
  if (Array.isArray(witnessIndexes)) {
    if (witnessIndexes.length === 0) {
      throw new Error("The witnessIndexes must be not empty");
    }
    if (witnessIndexes.length > tx.inputs.length) {
      throw new Error(
        "The length of witnessIndexes must not be bigger than the length of inputs"
      );
    }
  }
  if (!config.popup) {
    config.popup = openPopup("");
    if (!config.popup) {
      return createBlockDialog(
        async () => signRawTransaction(tx, signerAddress, config)
      );
    }
  }
  const { popup, timeoutInSeconds, ...ckbDappConfig } = config;
  config.popup.location.href = buildJoyIDURL(
    {
      ...ckbDappConfig,
      tx,
      signerAddress,
      redirectURL: location.href
    },
    "popup",
    "/sign-ckb-raw-tx"
  );
  const res = await runPopup({
    timeoutInSeconds: timeoutInSeconds ?? 5e3,
    popup,
    type: DappRequestType.SignCkbRawTx
  });
  return res.tx;
};
var SECP256R1_PUBKEY_SIG_LEN = 129;
var calculateChallenge = async (tx, witnessIndexes = [0]) => {
  const { witnesses } = tx;
  if (witnesses.length === 0) {
    throw new Error("Witnesses cannot be empty");
  }
  if (witnessIndexes.length === 0) {
    throw new Error("JoyID witnesses can not be empty");
  }
  const firstWitnessIndex = witnessIndexes[0] ?? 0;
  if (typeof tx.witnesses[firstWitnessIndex] !== "string") {
    throw new TypeError(
      "The first JoyID witness must be serialized hex string of WitnessArgs"
    );
  }
  const transactionHash = rawTransactionToHash(tx);
  const witnessArgs = deserializeWitnessArgs(tx.witnesses[firstWitnessIndex]);
  const emptyWitness = {
    ...witnessArgs,
    lock: `0x${"00".repeat(SECP256R1_PUBKEY_SIG_LEN)}`
  };
  console.log(console.log(emptyWitness));
  const serializedEmptyWitnessBytes = hexToBytes2(
    serializeWitnessArgs(emptyWitness)
  );
  const serializedEmptyWitnessSize = serializedEmptyWitnessBytes.length;
  const hasher = blake2b(32, null, null, PERSONAL);
  hasher.update(hexToBytes2(transactionHash));
  hasher.update(
    hexToBytes2(toUint64Le(`0x${serializedEmptyWitnessSize.toString(16)}`))
  );
  hasher.update(serializedEmptyWitnessBytes);
  for (const witnessIndex of witnessIndexes.slice(1)) {
    const witness = witnesses[witnessIndex];
    if (witness) {
      const bytes = hexToBytes2(
        typeof witness === "string" ? witness : serializeWitnessArgs(witness)
      );
      hasher.update(hexToBytes2(toUint64Le(`0x${bytes.length.toString(16)}`)));
      hasher.update(bytes);
    }
  }
  if (witnesses.length > tx.inputs.length) {
    for (const witness of witnesses.slice(tx.inputs.length)) {
      const bytes = hexToBytes2(
        typeof witness === "string" ? witness : serializeWitnessArgs(witness)
      );
      hasher.update(hexToBytes2(toUint64Le(`0x${bytes.length.toString(16)}`)));
      hasher.update(bytes);
    }
  }
  const challenge = `${hasher.digest("hex")}`;
  return challenge;
};
var WITNESS_NATIVE_MODE = "01";
var WITNESS_SUBKEY_MODE = "02";
var buildSignedTx = (unsignedTx, signedData, witnessIndexes = [0]) => {
  if (unsignedTx.witnesses.length === 0) {
    throw new Error("Witnesses length error");
  }
  const firstWitnessIndex = witnessIndexes[0] ?? 0;
  const firstWitness = unsignedTx.witnesses[firstWitnessIndex];
  const witnessArgs = deserializeWitnessArgs(firstWitness);
  const { message, signature, pubkey, keyType } = signedData;
  const mode = keyType === "sub_key" ? WITNESS_SUBKEY_MODE : WITNESS_NATIVE_MODE;
  witnessArgs.lock = `0x${mode}${pubkey}${signature}${message}`;
  const signedWitness = append0x2(serializeWitnessArgs(witnessArgs));
  const signedTx = unsignedTx;
  signedTx.witnesses[firstWitnessIndex] = signedWitness;
  return signedTx;
};
var getSubkeyUnlock = async (aggregatorUrl, connection) => {
  const pubkeyHash = append0x2(blake160(append0x2(connection.pubkey), "hex"));
  const lock = addressToScript(connection.address);
  const req = {
    lock_script: serializeScript(lock),
    pubkey_hash: pubkeyHash,
    alg_index: 1
    // secp256r1
  };
  const aggregator = new Aggregator(aggregatorUrl);
  const { unlock_entry: unlockEntry } = await aggregator.generateSubkeyUnlockSmt(req);
  return unlockEntry;
};
export {
  Aggregator,
  SigningAlg2 as SigningAlg,
  buildSignedTx,
  calculateChallenge,
  connect,
  ensureChallenge,
  getConfig2 as getConfig,
  getCotaCellDep,
  getCotaTypeScript,
  getJoyIDCellDep,
  getJoyIDLockScript,
  getSubkeyUnlock,
  initConfig,
  openPopup2 as openPopup,
  signChallenge,
  signCotaNFTTx,
  signRawTransaction,
  signTransaction,
  verifyCredential,
  verifyNativeKeySignature,
  verifySessionKeySignature,
  verifySignature
};
//# sourceMappingURL=index.mjs.map